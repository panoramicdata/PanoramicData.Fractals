@page "/"
@using PanoramicData.Fractals.Models
@using PanoramicData.Fractals.Services
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.WebUtilities
@inject WebGPUInterop WebGPU
@inject FractalState State
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@implements IAsyncDisposable

<PageTitle>Fractal Explorer</PageTitle>

<div class="fractal-container">
	<canvas id="fractal-canvas" @ref="canvasRef"></canvas>
	
	<!-- Fractal Type Selector -->
	<div class="fractal-controls">
		<div class="control-group">
			<label for="fractal-select">Fractal Type</label>
			<select id="fractal-select" @bind="selectedFractalType" @bind:after="OnFractalTypeChanged">
				@foreach (var fractalType in Enum.GetValues<FractalType>())
				{
					<option value="@fractalType">@GetFractalDisplayName(fractalType)</option>
				}
			</select>
		</div>
		
		<div class="control-group">
			<label for="palette-select">Color Palette</label>
			<select id="palette-select" @bind="selectedPaletteName" @bind:after="OnPaletteChanged">
				@foreach (var palette in ColorPalette.AllPalettes)
				{
					<option value="@palette.Name">@palette.Name</option>
				}
			</select>
		</div>
		
		<div class="control-group">
			<button class="reset-button" @onclick="OnResetView">
				<span class="reset-icon">↺</span> Reset View
			</button>
		</div>
	</div>
	
	<!-- FPS Counter -->
	@if (showFPS)
	{
		<div class="fps-counter">
			<div class="fps-value">@currentFPS FPS</div>
			<div class="fps-label">Performance</div>
		</div>
	}

	@if (!webGPUSupported)
	{
		<div class="webgpu-error">
			<h2>WebGPU Not Supported</h2>
			<p>Your browser doesn't support WebGPU. Please use Chrome 113+ or Edge 113+ for the best experience.</p>
		</div>
	}
	else if (isInitializing)
	{
		<div class="loading-overlay">
			<div class="spinner-border text-light" role="status">
				<span class="visually-hidden">Initializing WebGPU...</span>
			</div>
			<p class="mt-3 text-light">Initializing WebGPU...</p>
		</div>
	}
</div>

@code {
	private ElementReference canvasRef;
	private bool webGPUSupported = true;
	private bool isInitializing = true;
	private int canvasWidth;
	private int canvasHeight;
	private DotNetObjectReference<Home>? dotNetRef;
	private IJSObjectReference? windowEventsModule;
	private FractalType selectedFractalType = FractalType.Mandelbrot;
	private string selectedPaletteName = "Classic";
	private bool suppressUrlUpdate = false;
	
	// FPS tracking
	private bool showFPS = true;
	private int currentFPS = 0;
	private DateTime lastFrameTime = DateTime.UtcNow;
	private Queue<double> frameTimes = new(60);

	protected override void OnInitialized()
	{
		// Load settings from URL parameters
		LoadFromUrlParameters();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			// Get window size with 1:1 aspect ratio
			await UpdateCanvasSize();

			// Initialize WebGPU (this will check support internally)
			var initialized = await WebGPU.InitializeAsync("fractal-canvas");
			
			if (!initialized)
			{
				webGPUSupported = false;
				isInitializing = false;
				StateHasChanged();
				return;
			}

			// Subscribe to state changes
			State.OnStateChanged += OnStateChanged;
			
			// Set up resize handler
			dotNetRef = DotNetObjectReference.Create(this);
			windowEventsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
				"import", "./js/window-events.js");
			await windowEventsModule.InvokeVoidAsync("setupResizeHandler", dotNetRef);
			
			// Set up pan and zoom interaction
			await WebGPU.SetupInteractionAsync(dotNetRef);
			
			// Render initial fractal
			await RenderCurrentFractal();
			
			isInitializing = false;
			StateHasChanged();
		}
	}

	private void LoadFromUrlParameters()
	{
		var uri = new Uri(Navigation.Uri);
		var queryParams = QueryHelpers.ParseQuery(uri.Query);

		// Load fractal type
		if (queryParams.TryGetValue("fractal", out var fractalValue) &&
			!string.IsNullOrEmpty(fractalValue) &&
			Enum.TryParse<FractalType>(fractalValue, true, out var fractalType))
		{
			selectedFractalType = fractalType;
			State.CurrentFractal = fractalType;
		}

		// Load palette
		if (queryParams.TryGetValue("palette", out var paletteValue) &&
			!string.IsNullOrEmpty(paletteValue))
		{
			var palette = ColorPalette.AllPalettes.FirstOrDefault(p => 
				p.Name.Equals(paletteValue, StringComparison.OrdinalIgnoreCase));
			if (palette != null)
			{
				selectedPaletteName = palette.Name;
				State.CurrentPalette = palette;
			}
		}

		// Load center coordinates (supports complex notation like "0.1+0.3i" or separate x,y)
		if (queryParams.TryGetValue("c", out var centerValue) && !string.IsNullOrEmpty(centerValue))
		{
			var (real, imag) = ParseComplex(centerValue!);
			State.ViewPort.CenterX = real;
			State.ViewPort.CenterY = imag;
		}
		else
		{
			if (queryParams.TryGetValue("x", out var xValue) &&
				double.TryParse(xValue, out var x))
			{
				State.ViewPort.CenterX = x;
			}

			if (queryParams.TryGetValue("y", out var yValue) &&
				double.TryParse(yValue, out var y))
			{
				State.ViewPort.CenterY = y;
			}
		}

		// Load zoom level
		if (queryParams.TryGetValue("zoom", out var zoomValue) &&
			double.TryParse(zoomValue, out var zoom))
		{
			State.ViewPort.Zoom = Math.Max(0.1, Math.Min(zoom, 1e15));
		}

		// Load max iterations
		if (queryParams.TryGetValue("iter", out var iterValue) &&
			int.TryParse(iterValue, out var iterations))
		{
			State.MaxIterations = Math.Max(10, Math.Min(iterations, 10000));
		}
	}

	private (double Real, double Imag) ParseComplex(string complexStr)
	{
		// Handle formats like: "0.1+0.3i", "0.1-0.3i", "-0.4+0.6i"
		complexStr = complexStr.Replace(" ", "").Replace("i", "").ToLower();
		
		var real = 0.0;
		var imag = 0.0;

		// Find the last + or - that's not at the beginning
		var lastPlusIndex = complexStr.LastIndexOf('+');
		var lastMinusIndex = complexStr.LastIndexOf('-');
		
		// Skip the first character (could be negative sign for real part)
		if (lastMinusIndex == 0)
		{
			lastMinusIndex = complexStr.LastIndexOf('-', 1);
		}

		var splitIndex = Math.Max(lastPlusIndex, lastMinusIndex);

		if (splitIndex > 0)
		{
			if (double.TryParse(complexStr[..splitIndex], out real))
			{
				var imagPart = complexStr[splitIndex..];
				double.TryParse(imagPart, out imag);
			}
		}
		else if (double.TryParse(complexStr, out real))
		{
			// Only real part provided
			imag = 0.0;
		}

		return (real, imag);
	}

	private void UpdateUrl()
	{
		if (suppressUrlUpdate) return;

		var queryParams = new Dictionary<string, string?>
		{
			["fractal"] = State.CurrentFractal.ToString().ToLowerInvariant(),
			["palette"] = selectedPaletteName.ToLowerInvariant().Replace(" ", ""),
			["c"] = FormatComplex(State.ViewPort.CenterX, State.ViewPort.CenterY),
			["zoom"] = State.ViewPort.Zoom.ToString("G6"),
			["iter"] = State.MaxIterations.ToString()
		};

		var newUri = QueryHelpers.AddQueryString("/", queryParams);
		Navigation.NavigateTo(newUri, replace: true);
	}

	private string FormatComplex(double real, double imag)
	{
		var realStr = real.ToString("G6");
		var imagStr = Math.Abs(imag).ToString("G6");
		var sign = imag >= 0 ? "+" : "-";
		return $"{realStr}{sign}{imagStr}i";
	}

	[JSInvokable]
	public async Task OnWindowResized()
	{
		// Update canvas size to maintain 1:1 aspect ratio
		await UpdateCanvasSize();
		
		// Re-render fractal with new dimensions
		await RenderCurrentFractal();
		
		StateHasChanged();
	}

	[JSInvokable]
	public async Task OnPan(double deltaX, double deltaY)
	{
		// Convert pixel delta to complex plane delta
		// Negative because moving mouse right should move view left
		var scale = 4.0 / State.ViewPort.Zoom;
		var deltaReal = -(deltaX / canvasWidth) * scale;
		var deltaImag = -(deltaY / canvasHeight) * scale;
		
		State.ViewPort.CenterX += deltaReal;
		State.ViewPort.CenterY += deltaImag;
		
		await RenderCurrentFractal();
		UpdateUrl();
	}

	[JSInvokable]
	public async Task OnZoom(double zoomDelta, double normalizedX, double normalizedY)
	{
		// Calculate the point in complex plane where zoom is centered
		var scale = 4.0 / State.ViewPort.Zoom;
		var pointReal = State.ViewPort.CenterX + (normalizedX - 0.5) * scale;
		var pointImag = State.ViewPort.CenterY + (normalizedY - 0.5) * scale;
		
		// Apply zoom
		State.ViewPort.Zoom *= zoomDelta;
		
		// Limit zoom range
		State.ViewPort.Zoom = Math.Max(0.1, Math.Min(State.ViewPort.Zoom, 1e15));
		
		// Adjust center to keep the zoom point fixed
		var newScale = 4.0 / State.ViewPort.Zoom;
		State.ViewPort.CenterX = pointReal - (normalizedX - 0.5) * newScale;
		State.ViewPort.CenterY = pointImag - (normalizedY - 0.5) * newScale;
		
		await RenderCurrentFractal();
		UpdateUrl();
	}

	private async Task OnFractalTypeChanged()
	{
		State.CurrentFractal = selectedFractalType;
		
		// Reset view for new fractal type
		ResetView();
		
		await RenderCurrentFractal();
		UpdateUrl();
	}

	private async Task OnPaletteChanged()
	{
		var palette = ColorPalette.AllPalettes.FirstOrDefault(p => p.Name == selectedPaletteName);
		if (palette != null)
		{
			State.CurrentPalette = palette;
			await RenderCurrentFractal();
			UpdateUrl();
		}
	}

	private async Task OnResetView()
	{
		ResetView();
		await RenderCurrentFractal();
		UpdateUrl();
	}

	private void UpdateFPS()
	{
		var now = DateTime.UtcNow;
		var frameTime = (now - lastFrameTime).TotalMilliseconds;
		lastFrameTime = now;
		
		frameTimes.Enqueue(frameTime);
		if (frameTimes.Count > 60)
		{
			frameTimes.Dequeue();
		}
		
		if (frameTimes.Count > 0)
		{
			var avgFrameTime = frameTimes.Average();
			currentFPS = avgFrameTime > 0 ? (int)(1000.0 / avgFrameTime) : 0;
			StateHasChanged();
		}
	}

	private void ResetView()
	{
		State.ViewPort.CenterX = 0.0;
		State.ViewPort.CenterY = 0.0;
		State.ViewPort.Zoom = 1.0;
	}

	private string GetFractalDisplayName(FractalType fractalType) => fractalType switch
	{
		FractalType.Mandelbrot => "Mandelbrot Set",
		FractalType.Julia => "Julia Set",
		FractalType.BurningShip => "Burning Ship",
		FractalType.Newton => "Newton Fractal",
		FractalType.Tricorn => "Tricorn (Mandelbar)",
		FractalType.Phoenix => "Phoenix",
		FractalType.BarnsleyFern => "Barnsley Fern",
		_ => fractalType.ToString()
	};

	private async Task UpdateCanvasSize()
	{
		// Get square canvas dimensions (1:1 aspect ratio)
		var (width, height) = await WebGPU.GetCanvasSizeAsync();
		
		canvasWidth = width;
		canvasHeight = height;
		
		State.ViewPort.Width = canvasWidth;
		State.ViewPort.Height = canvasHeight;
		
		await WebGPU.ResizeCanvasAsync(canvasWidth, canvasHeight);
	}

	private async void OnStateChanged()
	{
		await RenderCurrentFractal();
		UpdateUrl();
		StateHasChanged();
	}

	private async Task RenderCurrentFractal()
	{
		if (State.IsRendering) return;

		try
		{
			State.IsRendering = true;
			
			// Convert palette to float array
			var paletteData = GeneratePaletteData(State.CurrentPalette);
			
			await WebGPU.RenderFractalAsync(
				State.CurrentFractal,
				State.ViewPort,
				State.MaxIterations,
				paletteData
			);
			
			// Update FPS counter
			UpdateFPS();
		}
		finally
		{
			State.IsRendering = false;
		}
	}

	private float[] GeneratePaletteData(ColorPalette palette)
	{
		const int paletteSize = 256;
		var data = new float[paletteSize * 4]; // RGBA

		for (int i = 0; i < paletteSize; i++)
		{
			var t = i / (float)(paletteSize - 1);
			var color = InterpolateColor(palette, t);
			
			data[i * 4 + 0] = color.R / 255f;
			data[i * 4 + 1] = color.G / 255f;
			data[i * 4 + 2] = color.B / 255f;
			data[i * 4 + 3] = 1.0f;
		}

		return data;
	}

	private (byte R, byte G, byte B) InterpolateColor(ColorPalette palette, float t)
	{
		if (palette.Colors.Count == 0)
			return (0, 0, 0);

		if (palette.Colors.Count == 1)
			return (palette.Colors[0].R, palette.Colors[0].G, palette.Colors[0].B);

		// Find the two colors to interpolate between
		ColorStop? lower = null;
		ColorStop? upper = null;

		for (int i = 0; i < palette.Colors.Count - 1; i++)
		{
			if (t >= palette.Colors[i].Position && t <= palette.Colors[i + 1].Position)
			{
				lower = palette.Colors[i];
				upper = palette.Colors[i + 1];
				break;
			}
		}

		if (lower == null || upper == null)
		{
			var lastColor = palette.Colors[^1];
			return (lastColor.R, lastColor.G, lastColor.B);
		}

		// Interpolate
		var range = upper.Position - lower.Position;
		var localT = range > 0 ? (t - lower.Position) / range : 0;

		var r = (byte)(lower.R + (upper.R - lower.R) * localT);
		var g = (byte)(lower.G + (upper.G - lower.G) * localT);
		var b = (byte)(lower.B + (upper.B - lower.B) * localT);

		return (r, g, b);
	}

	public async ValueTask DisposeAsync()
	{
		State.OnStateChanged -= OnStateChanged;
		
		if (windowEventsModule != null)
		{
			await windowEventsModule.InvokeVoidAsync("removeResizeHandler");
			await windowEventsModule.DisposeAsync();
		}
		
		dotNetRef?.Dispose();
		
		await WebGPU.DisposeAsync();
	}
}
