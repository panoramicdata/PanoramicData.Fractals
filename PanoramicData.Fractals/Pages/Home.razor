@page "/"
@using PanoramicData.Fractals.Models
@using PanoramicData.Fractals.Services
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.WebUtilities
@inject WebGPUInterop WebGPU
@inject FractalState State
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@implements IAsyncDisposable

<PageTitle>Fractal Explorer</PageTitle>

<div class="fractal-container">
	<canvas id="fractal-canvas" @ref="canvasRef"></canvas>

	<!-- Collapsible Control Panel (Top Right) -->
	<div class="control-panel @(isControlsExpanded ? "expanded" : "collapsed")">
		@if (isControlsExpanded)
		{
			<div class="panel-content">
				<button class="panel-toggle" @onclick="ToggleControls" title="Collapse controls">
					<span class="toggle-icon">√ó</span>
				</button>

				<div class="control-group">
					<label for="fractal-select">Fractal Type</label>
					<select id="fractal-select" @bind="selectedFractalType" @bind:after="OnFractalTypeChanged">
						@foreach (var fractalType in Enum.GetValues<FractalType>())
						{
							<option value="@fractalType">@GetFractalDisplayName(fractalType)</option>
						}
					</select>
				</div>

				<div class="control-group">
					<label for="palette-select">Color Palette</label>
					<select id="palette-select" @bind="selectedPaletteName" @bind:after="OnPaletteChanged">
						@foreach (var palette in ColorPalette.AllPalettes)
						{
							<option value="@palette.Name">@palette.Name</option>
						}
					</select>
				</div>

				<div class="control-group">
					<label for="iterations-input">Max Iterations</label>
					<input type="number" 
						   id="iterations-input" 
						   @bind="maxIterations" 
						   @bind:after="OnIterationsChanged"
						   min="1" 
						   max="10000" 
						   step="1" 
						   class="iterations-input" />
				</div>

				@if (State.Is3D)
				{
					<div class="control-group">
						<label for="rendermode-select">Rendering Mode</label>
						<select id="rendermode-select" @bind="selectedRenderMode" @bind:after="OnRenderModeChanged">
							@foreach (var mode in Enum.GetValues<Models.RenderMode>())
							{
								<option value="@mode">@GetRenderModeDisplayName(mode)</option>
							}
						</select>
					</div>
				}

				<div class="control-group">
					<button class="reset-button" @onclick="OnResetView">
						<span class="reset-icon">‚Ü∫</span> Reset View
					</button>
				</div>

				<div class="control-group">
					<button class="action-button screenshot-button" @onclick="OnCaptureScreenshot">
						<span class="button-icon">üì∑</span> Screenshot
					</button>
				</div>

				<div class="control-group">
					<button class="action-button help-button" @onclick="ToggleHelp">
						<span class="button-icon">‚ùì</span> Show Controls
					</button>
				</div>
			</div>
		}
		else
		{
			<button class="panel-toggle collapsed-toggle" @onclick="ToggleControls" title="Expand controls">
				<span class="toggle-icon">‚ò∞</span>
			</button>
		}
	</div>

	<!-- Help Overlay (Bottom Right) -->
	@if (isHelpVisible)
	{
		<div class="help-overlay">
			<div class="help-content">
				<button class="help-close" @onclick="ToggleHelp" title="Close help">√ó</button>
				<h3>Controls</h3>
				
				@if (State.Is3D)
				{
					<div class="help-section">
						<h4>3D Navigation</h4>
						<div class="help-item"><kbd>Mouse Drag</kbd> Rotate camera</div>
						<div class="help-item"><kbd>Shift + Drag</kbd> Move camera</div>
						<div class="help-item"><kbd>Scroll Wheel</kbd> Zoom in/out</div>
					</div>
					<div class="help-section">
						<h4>Keyboard</h4>
						<div class="help-item"><kbd>W / S</kbd> Forward/Back</div>
						<div class="help-item"><kbd>A / D</kbd> Strafe Left/Right</div>
						<div class="help-item"><kbd>Z / Q</kbd> Move Up/Down</div>
						<div class="help-item"><kbd>E / C</kbd> Zoom In/Out</div>
					</div>
				}
				else
				{
					<div class="help-section">
						<h4>2D Navigation</h4>
						<div class="help-item"><kbd>Mouse Drag</kbd> Pan view</div>
						<div class="help-item"><kbd>Scroll Wheel</kbd> Zoom in/out</div>
					</div>
				}
			</div>
		</div>
	}

	<!-- Landscape Legend (Bottom Left) - Only show for Landscape fractal -->
	@if (State.CurrentFractal == FractalType.Landscape)
	{
		<div class="landscape-legend">
			<h3>üó∫Ô∏è Landscape Layers</h3>
			<div class="legend-section">
				<h4>Terrain (Base)</h4>
				<div class="legend-item">
					<div class="color-swatch" style="background: linear-gradient(to right, rgb(217, 191, 140), rgb(217, 191, 140));"></div>
					<span>Beach / Sand</span>
				</div>
				<div class="legend-item">
					<div class="color-swatch" style="background: linear-gradient(to right, rgb(51, 166, 38), rgb(140, 115, 77));"></div>
					<span>Grassland / Plains</span>
				</div>
				<div class="legend-item">
					<div class="color-swatch" style="background: linear-gradient(to right, rgb(115, 102, 89), rgb(242, 242, 255));"></div>
					<span>Mountains ‚Üí Snow</span>
				</div>
			</div>
			<div class="legend-section">
				<h4>Water Layer</h4>
				<div class="legend-item">
					<div class="color-swatch" style="background: linear-gradient(to right, rgb(64, 179, 191), rgb(13, 64, 140));"></div>
					<span>Lakes (shallow ‚Üí deep)</span>
				</div>
				<div class="legend-item">
					<div class="color-swatch" style="background: rgb(51, 153, 230);"></div>
					<span>Rivers</span>
				</div>
			</div>
			<div class="legend-section">
				<h4>Vegetation Layer</h4>
				<div class="legend-item">
					<div class="color-swatch" style="background: rgb(20, 102, 20);"></div>
					<span>Forests</span>
				</div>
			</div>
			<div class="legend-section">
				<h4>Urban Layer</h4>
				<div class="legend-item">
					<div class="color-swatch" style="background: linear-gradient(to right, rgb(179, 153, 115), rgb(191, 191, 191));"></div>
					<span>Buildings</span>
				</div>
				<div class="legend-item">
					<div class="color-swatch" style="background: rgb(115, 115, 115);"></div>
					<span>Urban Areas</span>
				</div>
			</div>
			<div class="legend-section">
				<h4>Cloud Layer (Height)</h4>
				<div class="legend-item">
					<div class="color-swatch" style="background: linear-gradient(to right, rgb(255, 255, 255), rgb(153, 153, 166));"></div>
					<span>Thin ‚Üí Thick Clouds</span>
				</div>
			</div>
		</div>
	}

	@if (!webGPUSupported)
	{
		<div class="webgpu-error">
			<h2>WebGPU Not Supported</h2>
			<p>Your browser doesn't support WebGPU. Please use Chrome 113+ or Edge 113+ for the best experience.</p>
		</div>
	}
	else if (isInitializing)
	{
		<div class="loading-overlay">
			<div class="spinner-border text-light" role="status">
				<span class="visually-hidden">Initializing WebGPU...</span>
			</div>
			<p class="mt-3 text-light">Initializing WebGPU...</p>
		</div>
	}
</div>

<style>
	.help-overlay {
		position: absolute;
		bottom: 20px;
		right: 20px;
		background: rgba(0, 0, 0, 0.9);
		border: 1px solid rgba(255, 255, 255, 0.2);
		border-radius: 8px;
		padding: 20px;
		color: white;
		font-family: system-ui, -apple-system, sans-serif;
		min-width: 280px;
		max-width: 320px;
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
		z-index: 1000;
	}

	.help-content {
		position: relative;
	}

	.help-close {
		position: absolute;
		top: -10px;
		right: -10px;
		background: rgba(255, 255, 255, 0.1);
		border: 1px solid rgba(255, 255, 255, 0.2);
		border-radius: 4px;
		color: white;
		width: 28px;
		height: 28px;
		display: flex;
		align-items: center;
		justify-content: center;
		cursor: pointer;
		font-size: 20px;
		line-height: 1;
		transition: all 0.2s;
		padding: 0;
	}

	.help-close:hover {
		background: rgba(255, 255, 255, 0.2);
		transform: scale(1.1);
	}

	.help-content h3 {
		margin: 0 0 15px 0;
		font-size: 18px;
		font-weight: 600;
		color: #4CAF50;
	}

	.help-section {
		margin-bottom: 15px;
	}

	.help-section:last-child {
		margin-bottom: 0;
	}

	.help-section h4 {
		margin: 0 0 8px 0;
		font-size: 14px;
		font-weight: 600;
		color: rgba(255, 255, 255, 0.7);
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}

	.help-item {
		display: flex;
		align-items: center;
		margin-bottom: 6px;
		font-size: 13px;
		line-height: 1.4;
	}

	.help-item kbd {
		background: rgba(255, 255, 255, 0.1);
		border: 1px solid rgba(255, 255, 255, 0.2);
		border-radius: 3px;
		padding: 2px 6px;
		font-family: 'Courier New', monospace;
		font-size: 11px;
		margin-right: 8px;
		white-space: nowrap;
		min-width: 100px;
		display: inline-block;
	}

	.help-button {
		background: rgba(76, 175, 80, 0.2);
		border: 1px solid rgba(76, 175, 80, 0.4);
	}

	.help-button:hover {
		background: rgba(76, 175, 80, 0.3);
		border-color: rgba(76, 175, 80, 0.6);
	}

	/* Landscape Legend Styles */
	.landscape-legend {
		position: absolute;
		bottom: 20px;
		left: 20px;
		background: rgba(0, 0, 0, 0.9);
		border: 1px solid rgba(255, 255, 255, 0.2);
		border-radius: 8px;
		padding: 15px;
		color: white;
		font-family: system-ui, -apple-system, sans-serif;
		max-width: 280px;
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
		z-index: 999;
	}

	.landscape-legend h3 {
		margin: 0 0 12px 0;
		font-size: 16px;
		font-weight: 600;
		color: #4CAF50;
		border-bottom: 1px solid rgba(255, 255, 255, 0.1);
		padding-bottom: 8px;
	}

	.legend-section {
		margin-bottom: 12px;
	}

	.legend-section:last-child {
		margin-bottom: 0;
	}

	.legend-section h4 {
		margin: 0 0 6px 0;
		font-size: 12px;
		font-weight: 600;
		color: rgba(255, 255, 255, 0.6);
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}

	.legend-item {
		display: flex;
		align-items: center;
		margin-bottom: 4px;
		font-size: 12px;
	}

	.legend-item:last-child {
		margin-bottom: 0;
	}

	.color-swatch {
		width: 40px;
		height: 16px;
		border-radius: 3px;
		margin-right: 8px;
		border: 1px solid rgba(255, 255, 255, 0.3);
		flex-shrink: 0;
	}

	.legend-item span {
		color: rgba(255, 255, 255, 0.9);
	}

	.iterations-input {
		width: 100%;
		padding: 8px;
		border: 1px solid rgba(255, 255, 255, 0.2);
		border-radius: 4px;
		background: rgba(255, 255, 255, 0.1);
		color: white;
		font-size: 14px;
		font-family: system-ui, -apple-system, sans-serif;
	}

	.iterations-input:focus {
		outline: none;
		border-color: #4CAF50;
		background: rgba(255, 255, 255, 0.15);
	}

	.iterations-input::-webkit-inner-spin-button,
	.iterations-input::-webkit-outer-spin-button {
		opacity: 1;
	}
</style>

@code {
	private ElementReference canvasRef;
	private bool webGPUSupported = true;
	private bool isInitializing = true;
	private int canvasWidth;
	private int canvasHeight;
	private DotNetObjectReference<Home>? dotNetRef;
	private IJSObjectReference? windowEventsModule;
	private FractalType selectedFractalType = FractalType.Mandelbrot;
	private string selectedPaletteName = "Classic";
	private Models.RenderMode selectedRenderMode = Models.RenderMode.DistanceEstimation;
	private bool suppressUrlUpdate = false;
	private bool isControlsExpanded = true; // Default to expanded
	private bool isHelpVisible = false; // Help overlay visibility
	private int maxIterations = 2048; // Default to 2048

	protected override void OnInitialized()
	{
		// Load settings from URL parameters
		LoadFromUrlParameters();
		
		// Sync with state
		maxIterations = State.MaxIterations;
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			// Get window size with 1:1 aspect ratio
			await UpdateCanvasSize();

			// Initialize WebGPU (this will check support internally)
			var initialized = await WebGPU.InitializeAsync("fractal-canvas");

			if (!initialized)
			{
				webGPUSupported = false;
				isInitializing = false;
				StateHasChanged();
				return;
			}

			// Subscribe to state changes
			State.OnStateChanged += OnStateChanged;

			// Set up resize handler
			dotNetRef = DotNetObjectReference.Create(this);
			windowEventsModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
				"import", "./js/window-events.js");
			await windowEventsModule.InvokeVoidAsync("setupResizeHandler", dotNetRef);

			// Set up pan and zoom interaction
			await WebGPU.SetupInteractionAsync(dotNetRef);

			// Render initial fractal
			await RenderCurrentFractal();

			isInitializing = false;
			StateHasChanged();
		}
	}

	private void LoadFromUrlParameters()
	{
		var uri = new Uri(Navigation.Uri);
		var queryParams = QueryHelpers.ParseQuery(uri.Query);

		// Load fractal type
		if (queryParams.TryGetValue("fractal", out var fractalValue) &&
			!string.IsNullOrEmpty(fractalValue) &&
			Enum.TryParse<FractalType>(fractalValue, true, out var fractalType))
		{
			selectedFractalType = fractalType;
			State.CurrentFractal = fractalType;
		}

		// Load palette
		if (queryParams.TryGetValue("palette", out var paletteValue) &&
			!string.IsNullOrEmpty(paletteValue))
		{
			var palette = ColorPalette.AllPalettes.FirstOrDefault(p =>
				p.Name.Equals(paletteValue, StringComparison.OrdinalIgnoreCase));
			if (palette != null)
			{
				selectedPaletteName = palette.Name;
				State.CurrentPalette = palette;
			}
		}

		// Load max iterations
		if (queryParams.TryGetValue("iter", out var iterValue) &&
			int.TryParse(iterValue, out var iterations))
		{
			maxIterations = Math.Max(10, Math.Min(iterations, 10000));
			State.MaxIterations = maxIterations;
		}

		// Load center coordinates (supports complex notation like "0.1+0.3i" or separate x,y)
		if (queryParams.TryGetValue("c", out var centerValue) && !string.IsNullOrEmpty(centerValue))
		{
			var (real, imag) = ParseComplex(centerValue!);
			State.ViewPort.CenterX = real;
			State.ViewPort.CenterY = imag;
		}
		else
		{
			if (queryParams.TryGetValue("x", out var xValue) &&
				double.TryParse(xValue, out var x))
			{
				State.ViewPort.CenterX = x;
			}

			if (queryParams.TryGetValue("y", out var yValue) &&
				double.TryParse(yValue, out var y))
			{
				State.ViewPort.CenterY = y;
			}
		}

		// Load zoom level
		if (queryParams.TryGetValue("zoom", out var zoomValue) &&
			double.TryParse(zoomValue, out var zoom))
		{
			State.ViewPort.Zoom = Math.Max(0.1, Math.Min(zoom, 1e10));
		}

		// Load 3D camera parameters
		if (queryParams.TryGetValue("cx", out var cxValue) &&
			double.TryParse(cxValue, out var cx))
		{
			State.Camera3D.PositionX = cx;
		}

		if (queryParams.TryGetValue("cy", out var cyValue) &&
			double.TryParse(cyValue, out var cy))
		{
			State.Camera3D.PositionY = cy;
		}

		if (queryParams.TryGetValue("cz", out var czValue) &&
			double.TryParse(czValue, out var cz))
		{
			State.Camera3D.PositionZ = cz;
		}

		if (queryParams.TryGetValue("yaw", out var yawValue) &&
			double.TryParse(yawValue, out var yaw))
		{
			State.Camera3D.Yaw = yaw;
		}

		if (queryParams.TryGetValue("pitch", out var pitchValue) &&
			double.TryParse(pitchValue, out var pitch))
		{
			State.Camera3D.Pitch = pitch;
		}

		if (queryParams.TryGetValue("fov", out var fovValue) &&
			double.TryParse(fovValue, out var fov))
		{
			State.Camera3D.FieldOfView = Math.Clamp(fov, 1e-10, 3.0);
		}

		// Load render mode for 3D fractals
		if (queryParams.TryGetValue("rendermode", out var renderModeValue) &&
			!string.IsNullOrEmpty(renderModeValue) &&
			Enum.TryParse<Models.RenderMode>(renderModeValue, true, out var renderMode))
		{
			selectedRenderMode = renderMode;
			State.RenderMode = renderMode;
		}
	}

	private (double Real, double Imag) ParseComplex(string complexStr)
	{
		// Handle formats like: "0.1+0.3i", "0.1-0.3i", "-0.4+0.6i"
		complexStr = complexStr.Replace(" ", "").Replace("i", "").ToLower();

		var real = 0.0;
		var imag = 0.0;

		// Find the last + or - that's not at the beginning
		var lastPlusIndex = complexStr.LastIndexOf('+');
		var lastMinusIndex = complexStr.LastIndexOf('-');

		// Skip the first character (could be negative sign for real part)
		if (lastMinusIndex == 0)
		{
			lastMinusIndex = complexStr.LastIndexOf('-', 1);
		}

		var splitIndex = Math.Max(lastPlusIndex, lastMinusIndex);

		if (splitIndex > 0)
		{
			if (double.TryParse(complexStr[..splitIndex], out real))
			{
				var imagPart = complexStr[splitIndex..];
				double.TryParse(imagPart, out imag);
			}
		}
		else if (double.TryParse(complexStr, out real))
		{
			// Only real part provided
			imag = 0.0;
		}

		return (real, imag);
	}

	private void UpdateUrl()
	{
		if (suppressUrlUpdate) return;

		var queryParams = new Dictionary<string, string ?>
		{
			["fractal"] = State.CurrentFractal.ToString().ToLowerInvariant(),
			["palette"] = selectedPaletteName.ToLowerInvariant().Replace(" ", ""),
			["iter"] = State.MaxIterations.ToString()
		};

		// Add fractal-specific parameters
		if (State.Is3D)
		{
			// 3D camera parameters
			queryParams["cx"] = State.Camera3D.PositionX.ToString("G6");
			queryParams["cy"] = State.Camera3D.PositionY.ToString("G6");
			queryParams["cz"] = State.Camera3D.PositionZ.ToString("G6");
			queryParams["yaw"] = State.Camera3D.Yaw.ToString("G6");
			queryParams["pitch"] = State.Camera3D.Pitch.ToString("G6");
			queryParams["fov"] = State.Camera3D.FieldOfView.ToString("G6");
			queryParams["rendermode"] = State.RenderMode.ToString().ToLowerInvariant();
		}
		else
		{
			// 2D viewport parameters
			queryParams["c"] = FormatComplex(State.ViewPort.CenterX, State.ViewPort.CenterY);
			queryParams["zoom"] = State.ViewPort.Zoom.ToString("G6");
		}

		var newUri = QueryHelpers.AddQueryString("/", queryParams);
		Navigation.NavigateTo(newUri, replace: true);
	}

	private string FormatComplex(double real, double imag)
	{
		var realStr = real.ToString("G6");
		var imagStr = Math.Abs(imag).ToString("G6");
		var sign = imag >= 0 ? "+" : "-";
		return $"{realStr}{sign}{imagStr}i";
	}

	[JSInvokable]
	public async Task OnWindowResized()
	{
		// Update canvas size to maintain 1:1 aspect ratio
		await UpdateCanvasSize();

		// Re-render fractal with new dimensions
		await RenderCurrentFractal();

		StateHasChanged();
	}

	[JSInvokable]
	public async Task OnPan(double deltaX, double deltaY)
	{
		// For 3D Mandelbulb: rotate camera (yaw/pitch)
		if (State.Is3D)
		{
			// Sensitivity scales with FOV (linear) - halved for even slower rotation when zoomed in
			var sensitivity = 0.0025 * State.Camera3D.FieldOfView;

			// Update yaw (left/right) - REVERSED
			State.Camera3D.Yaw -= deltaX * sensitivity;

			// Update pitch (up/down), clamped to avoid gimbal lock - INVERTED Y
			State.Camera3D.Pitch -= deltaY * sensitivity;
			State.Camera3D.Pitch = Math.Clamp(State.Camera3D.Pitch, -Math.PI / 2 + 0.1, Math.PI / 2 - 0.1);
		}
		else
		{
			// For 2D fractals: pan the viewport
			var aspect = (double)canvasWidth / canvasHeight;
			var scale = 4.0 / State.ViewPort.Zoom;
			var deltaReal = -(deltaX / canvasWidth) * scale * aspect;
			var deltaImag = -(deltaY / canvasHeight) * scale;

			State.ViewPort.CenterX += deltaReal;
			State.ViewPort.CenterY += deltaImag;
		}

		await RenderCurrentFractal();
		UpdateUrl();
	}

	[JSInvokable]
	public async Task OnCameraPan(double deltaX, double deltaY)
	{
		// 3D camera position movement (Shift+drag) - REVERSED X/Y
		if (!State.Is3D) return;

		// Movement speed scales with FOV^2 for stronger zoom dampening
		var speed = 0.01 * State.Camera3D.FieldOfView * State.Camera3D.FieldOfView;

		// Calculate camera's local axes from yaw and pitch
		var (forward, right, up) = GetCameraAxes();

		// Move camera position in screen-space directions - REVERSED
		// Horizontal drag = move along camera's right vector
		// Vertical drag = move along camera's up vector
		State.Camera3D.PositionX -= (deltaX * speed * right.X + deltaY * speed * up.X);
		State.Camera3D.PositionY -= (deltaX * speed * right.Y + deltaY * speed * up.Y);
		State.Camera3D.PositionZ -= (deltaX * speed * right.Z + deltaY * speed * up.Z);

		await RenderCurrentFractal();
		UpdateUrl();
	}

	[JSInvokable]
	public async Task OnKeyboardMove(string direction)
	{
		// Keyboard camera movement (WASD+QZ+EC)
		if (!State.Is3D) return;

		// Movement speed scales with FOV^2 for stronger zoom dampening
		var speed = 0.1 * State.Camera3D.FieldOfView * State.Camera3D.FieldOfView;

		// Calculate camera's local axes
		var (forward, right, up) = GetCameraAxes();

		switch (direction.ToLower())
		{
			case "w": // Forward
				State.Camera3D.PositionX += forward.X * speed;
				State.Camera3D.PositionY += forward.Y * speed;
				State.Camera3D.PositionZ += forward.Z * speed;
				break;
			case "s": // Backward
				State.Camera3D.PositionX -= forward.X * speed;
				State.Camera3D.PositionY -= forward.Y * speed;
				State.Camera3D.PositionZ -= forward.Z * speed;
				break;
			case "a": // Left
				State.Camera3D.PositionX -= right.X * speed;
				State.Camera3D.PositionY -= right.Y * speed;
				State.Camera3D.PositionZ -= right.Z * speed;
				break;
			case "d": // Right
				State.Camera3D.PositionX += right.X * speed;
				State.Camera3D.PositionY += right.Y * speed;
				State.Camera3D.PositionZ += right.Z * speed;
				break;
			case "z": // Up (SWAPPED with Q)
				State.Camera3D.PositionX += up.X * speed;
				State.Camera3D.PositionY += up.Y * speed;
				State.Camera3D.PositionZ += up.Z * speed;
				break;
			case "q": // Down (SWAPPED with Z)
				State.Camera3D.PositionX -= up.X * speed;
				State.Camera3D.PositionY -= up.Y * speed;
				State.Camera3D.PositionZ -= up.Z * speed;
				break;
			case "e": // Zoom in (decrease FOV) - NO LOWER LIMIT for infinite zoom!
				State.Camera3D.FieldOfView *= 0.9;
				State.Camera3D.FieldOfView = Math.Max(State.Camera3D.FieldOfView, 1e-10); // Only prevent complete zero
				break;
			case "c": // Zoom out (increase FOV) - Reasonable upper limit
				State.Camera3D.FieldOfView *= 1.1;
				State.Camera3D.FieldOfView = Math.Min(State.Camera3D.FieldOfView, 3.0);
				break;
		}

		await RenderCurrentFractal();
		UpdateUrl();
	}

	[JSInvokable]
	public async Task OnZoom(double zoomDelta, double normalizedX, double normalizedY)
	{
		if (State.Is3D)
		{
			// For 3D: adjust field of view - INFINITE ZOOM for fractals!
			State.Camera3D.FieldOfView *= zoomDelta;
			State.Camera3D.FieldOfView = Math.Clamp(State.Camera3D.FieldOfView, 1e-10, 3.0);
		}
		else
		{
			// For 2D fractals: zoom with pivot point
			var aspect = (double)canvasWidth / canvasHeight;
			var scale = 4.0 / State.ViewPort.Zoom;
			var pointReal = State.ViewPort.CenterX + (normalizedX - 0.5) * scale * aspect;
			var pointImag = State.ViewPort.CenterY + (normalizedY - 0.5) * scale;

			State.ViewPort.Zoom *= zoomDelta;
			State.ViewPort.Zoom = Math.Max(0.1, Math.Min(State.ViewPort.Zoom, 1e10));

			var newScale = 4.0 / State.ViewPort.Zoom;
			State.ViewPort.CenterX = pointReal - (normalizedX - 0.5) * newScale * aspect;
			State.ViewPort.CenterY = pointImag - (normalizedY - 0.5) * newScale;
		}

		await RenderCurrentFractal();
		UpdateUrl();
	}

	private void ResetView()
	{
		if (State.Is3D)
		{
			// Reset 3D camera to default position/orientation
			State.Camera3D.PositionX = 0.0;
			State.Camera3D.PositionY = 1.0;
			State.Camera3D.PositionZ = 3.0;
			State.Camera3D.Yaw = 0.0;
			State.Camera3D.Pitch = 0.3; // Slight downward angle
			State.Camera3D.FieldOfView = 1.0;
		}
		else
		{
			// Reset 2D viewport
			State.ViewPort.CenterX = 0.0;
			State.ViewPort.CenterY = 0.0;
			State.ViewPort.Zoom = 1.0;
		}
	}

	/// <summary>
	/// Calculate camera's local coordinate axes from yaw and pitch
	/// </summary>
	private ((double X, double Y, double Z) Forward, (double X, double Y, double Z) Right, (double X, double Y, double Z) Up) GetCameraAxes()
	{
		var yaw = State.Camera3D.Yaw;
		var pitch = State.Camera3D.Pitch;

		// Forward direction (where camera is looking)
		var forwardX = Math.Sin(yaw) * Math.Cos(pitch);
		var forwardY = Math.Sin(pitch);
		var forwardZ = -Math.Cos(yaw) * Math.Cos(pitch);

		// Right direction (perpendicular to forward, in horizontal plane)
		var rightX = Math.Cos(yaw);
		var rightY = 0.0;
		var rightZ = Math.Sin(yaw);

		// Up direction (cross product of right and forward)
		var upX = rightY * forwardZ - rightZ * forwardY;
		var upY = rightZ * forwardX - rightX * forwardZ;
		var upZ = rightX * forwardY - rightY * forwardX;

		return ((forwardX, forwardY, forwardZ), (rightX, rightY, rightZ), (upX, upY, upZ));
	}

	private async Task OnFractalTypeChanged()
	{
		State.CurrentFractal = selectedFractalType;
		
		// Set defaults specific to Mandelbulb
		if (selectedFractalType == FractalType.Mandelbulb)
		{
			// Set recommended camera position and orientation
			State.Camera3D.PositionX = 0.0;
			State.Camera3D.PositionY = 1.0;
			State.Camera3D.PositionZ = 3.0;
			State.Camera3D.Yaw = 0.005;
			State.Camera3D.Pitch = -0.32;
			State.Camera3D.FieldOfView = 0.891;
			
			// Set Psychedelic palette for Mandelbulb
			var psychedelicPalette = ColorPalette.AllPalettes.FirstOrDefault(p => 
				p.Name.Equals("Psychedelic", StringComparison.OrdinalIgnoreCase));
			if (psychedelicPalette != null)
			{
				selectedPaletteName = psychedelicPalette.Name;
				State.CurrentPalette = psychedelicPalette;
			}
			
			// Set Ray Traced render mode
			selectedRenderMode = Models.RenderMode.RayTraced;
			State.RenderMode = Models.RenderMode.RayTraced;
		}
		else
		{
			// Reset to 2D defaults
			ResetView();
		}
		
		await RenderCurrentFractal();
		UpdateUrl();
	}

	private async Task OnPaletteChanged()
	{
		var palette = ColorPalette.AllPalettes.FirstOrDefault(p => p.Name == selectedPaletteName);
		if (palette != null)
		{
			State.CurrentPalette = palette;
			await RenderCurrentFractal();
			UpdateUrl();
		}
	}

	private async Task OnIterationsChanged()
	{
		// Clamp the value to valid range
		maxIterations = Math.Clamp(maxIterations, 1, 10000);
		State.MaxIterations = maxIterations;
		await RenderCurrentFractal();
		UpdateUrl();
	}

	private async Task OnRenderModeChanged()
	{
		State.SetRenderMode(selectedRenderMode);
		await RenderCurrentFractal();
		UpdateUrl();
	}

	private async Task OnResetView()
	{
		ResetView();
		await RenderCurrentFractal();
		UpdateUrl();
	}

	private async Task OnCaptureScreenshot()
	{
		var fractalName = State.CurrentFractal.ToString().ToLowerInvariant();
		var timestamp = DateTime.Now.ToString("yyyyMMdd-HHmmss");
		var filename = $"fractal-{fractalName}-{timestamp}.png";

		await WebGPU.CaptureScreenshotAsync(filename);
	}

	private void ToggleControls()
	{
		isControlsExpanded = !isControlsExpanded;
	}

	private void ToggleHelp()
	{
	 isHelpVisible = !isHelpVisible;
	}

	private string GetRenderModeDisplayName(Models.RenderMode renderMode) => renderMode switch
	{
		Models.RenderMode.DistanceEstimation => "Distance Estimation",
		Models.RenderMode.SimpleShading => "Simple Shading",
		Models.RenderMode.RayTraced => "Ray Traced",
		_ => renderMode.ToString()
	};

	private string GetFractalDisplayName(FractalType fractalType) => fractalType switch
	{
		FractalType.Mandelbrot => "Mandelbrot Set",
		FractalType.Julia => "Julia Set",
		FractalType.BurningShip => "Burning Ship",
		FractalType.Newton => "Newton Fractal",
		FractalType.Tricorn => "Tricorn (Mandelbar)",
		FractalType.Phoenix => "Phoenix",
		FractalType.BarnsleyFern => "Barnsley Fern",
		FractalType.Mandelbulb => "Mandelbulb (3D)",
		_ => fractalType.ToString()
	};

	private async Task UpdateCanvasSize()
	{
		var (width, height) = await WebGPU.GetCanvasSizeAsync();
		canvasWidth = width;
		canvasHeight = height;
		State.ViewPort.Width = canvasWidth;
		State.ViewPort.Height = canvasHeight;
		await WebGPU.ResizeCanvasAsync(canvasWidth, canvasHeight);
	}

	private async void OnStateChanged()
	{
		if (State.IsRendering) return;
		await RenderCurrentFractal();
		UpdateUrl();
		StateHasChanged();
	}

	private async Task RenderCurrentFractal()
	{
		if (State.IsRendering) return;

		try
		{
			State.IsRendering = true;
			var paletteData = GeneratePaletteData(State.CurrentPalette);
			await WebGPU.RenderFractalAsync(
				State.CurrentFractal,
				State.ViewPort,
				State.Camera3D,
				State.Is3D,
				State.MaxIterations,
				paletteData,
				State.RenderMode
			);
		}
		finally
		{
			State.IsRendering = false;
		}
	}

	private float[] GeneratePaletteData(ColorPalette palette)
	{
		const int paletteSize = 256;
		var data = new float[paletteSize * 4];

		for (int i = 0; i < paletteSize; i++)
		{
			var t = i / (float)(paletteSize - 1);
			var color = InterpolateColor(palette, t);
			data[i * 4 + 0] = color.R / 255f;
			data[i * 4 + 1] = color.G / 255f;
			data[i * 4 + 2] = color.B / 255f;
			data[i * 4 + 3] = 1.0f;
		}

		return data;
	}

	private (byte R, byte G, byte B) InterpolateColor(ColorPalette palette, float t)
	{
		if (palette.Colors.Count == 0)
			return (0, 0, 0);

		if (palette.Colors.Count == 1)
			return (palette.Colors[0].R, palette.Colors[0].G, palette.Colors[0].B);

		ColorStop? lower = null;
		ColorStop? upper = null;

		for (int i = 0; i < palette.Colors.Count - 1; i++)
		{
			if (t >= palette.Colors[i].Position && t <= palette.Colors[i + 1].Position)
			{
				lower = palette.Colors[i];
				upper = palette.Colors[i + 1];
				break;
			}
		}

		if (lower == null || upper == null)
		{
			var lastColor = palette.Colors[^1];
			return (lastColor.R, lastColor.G, lastColor.B);
		}

		var range = upper.Position - lower.Position;
		var localT = range > 0 ? (t - lower.Position) / range : 0;

		var r = (byte)(lower.R + (upper.R - lower.R) * localT);
		var g = (byte)(lower.G + (upper.G - lower.G) * localT);
		var b = (byte)(lower.B + (upper.B - lower.B) * localT);

		return (r, g, b);
	}

	public async ValueTask DisposeAsync()
	{
		State.OnStateChanged -= OnStateChanged;

		if (windowEventsModule != null)
		{
			await windowEventsModule.InvokeVoidAsync("removeResizeHandler");
			await windowEventsModule.DisposeAsync();
		}

		dotNetRef?.Dispose();
		await WebGPU.DisposeAsync();
	}
}
